## Task 1
### Subtask А
  По формуле `m * (1 - (1 - 1 / m) ^ k)` (где m – число страниц, k – число кортежей), получаем ответ: __1000000 * (1 - (1 - 1  /1000000) ^ k) * 28 мс__.

### Subtask B

Время на последовательный доступ: __1000000 * 0.28 = 280000 мс__. 
Этот подход будет предпочтительнее, когда __280000 < 28000000 * (1 - (1 - 1 / 1000000) ^ k)__. Неравенство выполняется при __k >= 10051__, иными словами, тогда полное сканирование выгоднее.

Для прочтения всех кортежей в случае B-дерева общее время запроса - 28000000 мс, в случае последовательного доступа - 280000 мс, то есть на __27720000 мс__ выгоднее.

## Task 2

 Пусть в двух таблицах по t1 и t2 страниц соответсвенно, и у каждой размер страницы p1 и p2 соответственно. Тогда:

**Nested-loop Join** - минимальный размер буфера - __p1 + p2__, максимальный - __t1 * p1 + t2 * p2__.

**Hash Join** - так как необходимо держать в памяти целиком захешированную минимальную таблицу, минимальный и максимальный равны __min(t1, t2) * HASH_SIZE__.

**Sort Merge Join** - минимально будет использовано __max(t1, t2) * COL_SIZE__, максимально - __max(t1 * p1 + t2 * p2, max(t1, t2) * COL_SIZE)__.

**Table Scan** - минимально использовано - __p1 + p2__, максимально использовано - __t1 * p1 + t2 * p2__.

**Index Scan** - аналогично Table Scan, плюс дополнительно необходимо держать еще индекс. То есть, минимальный размер - одна страница, максимальный - все дерево.
